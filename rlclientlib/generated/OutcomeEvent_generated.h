// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OUTCOMEEVENT_REINFORCEMENT_LEARNING_MESSAGES_FLATBUFF_H_
#define FLATBUFFERS_GENERATED_OUTCOMEEVENT_REINFORCEMENT_LEARNING_MESSAGES_FLATBUFF_H_

#include "flatbuffers/flatbuffers.h"

namespace reinforcement_learning {
namespace messages {
namespace flatbuff {

struct StringEvent;

struct NumericEvent;

struct ActionTakenEvent;

struct OutcomeEventHolder;

struct OutcomeEventBatch;

enum OutcomeEvent {
  OutcomeEvent_NONE = 0,
  OutcomeEvent_StringEvent = 1,
  OutcomeEvent_NumericEvent = 2,
  OutcomeEvent_ActionTakenEvent = 3,
  OutcomeEvent_MIN = OutcomeEvent_NONE,
  OutcomeEvent_MAX = OutcomeEvent_ActionTakenEvent
};

inline const OutcomeEvent (&EnumValuesOutcomeEvent())[4] {
  static const OutcomeEvent values[] = {
    OutcomeEvent_NONE,
    OutcomeEvent_StringEvent,
    OutcomeEvent_NumericEvent,
    OutcomeEvent_ActionTakenEvent
  };
  return values;
}

inline const char * const *EnumNamesOutcomeEvent() {
  static const char * const names[] = {
    "NONE",
    "StringEvent",
    "NumericEvent",
    "ActionTakenEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNameOutcomeEvent(OutcomeEvent e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOutcomeEvent()[index];
}

template<typename T> struct OutcomeEventTraits {
  static const OutcomeEvent enum_value = OutcomeEvent_NONE;
};

template<> struct OutcomeEventTraits<StringEvent> {
  static const OutcomeEvent enum_value = OutcomeEvent_StringEvent;
};

template<> struct OutcomeEventTraits<NumericEvent> {
  static const OutcomeEvent enum_value = OutcomeEvent_NumericEvent;
};

template<> struct OutcomeEventTraits<ActionTakenEvent> {
  static const OutcomeEvent enum_value = OutcomeEvent_ActionTakenEvent;
};

bool VerifyOutcomeEvent(flatbuffers::Verifier &verifier, const void *obj, OutcomeEvent type);
bool VerifyOutcomeEventVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct StringEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct StringEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringEvent::VT_VALUE, value);
  }
  explicit StringEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringEventBuilder &operator=(const StringEventBuilder &);
  flatbuffers::Offset<StringEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringEvent> CreateStringEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringEventBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringEvent> CreateStringEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return reinforcement_learning::messages::flatbuff::CreateStringEvent(
      _fbb,
      value ? _fbb.CreateString(value) : 0);
}

struct NumericEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct NumericEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(NumericEvent::VT_VALUE, value, 0.0f);
  }
  explicit NumericEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NumericEventBuilder &operator=(const NumericEventBuilder &);
  flatbuffers::Offset<NumericEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NumericEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<NumericEvent> CreateNumericEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  NumericEventBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ActionTakenEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ActionTakenEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(ActionTakenEvent::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit ActionTakenEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionTakenEventBuilder &operator=(const ActionTakenEventBuilder &);
  flatbuffers::Offset<ActionTakenEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionTakenEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActionTakenEvent> CreateActionTakenEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  ActionTakenEventBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct OutcomeEventHolder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENT_ID = 4,
    VT_PASS_PROBABILITY = 6,
    VT_THE_EVENT_TYPE = 8,
    VT_THE_EVENT = 10
  };
  const flatbuffers::String *event_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EVENT_ID);
  }
  float pass_probability() const {
    return GetField<float>(VT_PASS_PROBABILITY, 0.0f);
  }
  OutcomeEvent the_event_type() const {
    return static_cast<OutcomeEvent>(GetField<uint8_t>(VT_THE_EVENT_TYPE, 0));
  }
  const void *the_event() const {
    return GetPointer<const void *>(VT_THE_EVENT);
  }
  template<typename T> const T *the_event_as() const;
  const StringEvent *the_event_as_StringEvent() const {
    return the_event_type() == OutcomeEvent_StringEvent ? static_cast<const StringEvent *>(the_event()) : nullptr;
  }
  const NumericEvent *the_event_as_NumericEvent() const {
    return the_event_type() == OutcomeEvent_NumericEvent ? static_cast<const NumericEvent *>(the_event()) : nullptr;
  }
  const ActionTakenEvent *the_event_as_ActionTakenEvent() const {
    return the_event_type() == OutcomeEvent_ActionTakenEvent ? static_cast<const ActionTakenEvent *>(the_event()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENT_ID) &&
           verifier.Verify(event_id()) &&
           VerifyField<float>(verifier, VT_PASS_PROBABILITY) &&
           VerifyField<uint8_t>(verifier, VT_THE_EVENT_TYPE) &&
           VerifyOffset(verifier, VT_THE_EVENT) &&
           VerifyOutcomeEvent(verifier, the_event(), the_event_type()) &&
           verifier.EndTable();
  }
};

template<> inline const StringEvent *OutcomeEventHolder::the_event_as<StringEvent>() const {
  return the_event_as_StringEvent();
}

template<> inline const NumericEvent *OutcomeEventHolder::the_event_as<NumericEvent>() const {
  return the_event_as_NumericEvent();
}

template<> inline const ActionTakenEvent *OutcomeEventHolder::the_event_as<ActionTakenEvent>() const {
  return the_event_as_ActionTakenEvent();
}

struct OutcomeEventHolderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event_id(flatbuffers::Offset<flatbuffers::String> event_id) {
    fbb_.AddOffset(OutcomeEventHolder::VT_EVENT_ID, event_id);
  }
  void add_pass_probability(float pass_probability) {
    fbb_.AddElement<float>(OutcomeEventHolder::VT_PASS_PROBABILITY, pass_probability, 0.0f);
  }
  void add_the_event_type(OutcomeEvent the_event_type) {
    fbb_.AddElement<uint8_t>(OutcomeEventHolder::VT_THE_EVENT_TYPE, static_cast<uint8_t>(the_event_type), 0);
  }
  void add_the_event(flatbuffers::Offset<void> the_event) {
    fbb_.AddOffset(OutcomeEventHolder::VT_THE_EVENT, the_event);
  }
  explicit OutcomeEventHolderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OutcomeEventHolderBuilder &operator=(const OutcomeEventHolderBuilder &);
  flatbuffers::Offset<OutcomeEventHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutcomeEventHolder>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutcomeEventHolder> CreateOutcomeEventHolder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> event_id = 0,
    float pass_probability = 0.0f,
    OutcomeEvent the_event_type = OutcomeEvent_NONE,
    flatbuffers::Offset<void> the_event = 0) {
  OutcomeEventHolderBuilder builder_(_fbb);
  builder_.add_the_event(the_event);
  builder_.add_pass_probability(pass_probability);
  builder_.add_event_id(event_id);
  builder_.add_the_event_type(the_event_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<OutcomeEventHolder> CreateOutcomeEventHolderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *event_id = nullptr,
    float pass_probability = 0.0f,
    OutcomeEvent the_event_type = OutcomeEvent_NONE,
    flatbuffers::Offset<void> the_event = 0) {
  return reinforcement_learning::messages::flatbuff::CreateOutcomeEventHolder(
      _fbb,
      event_id ? _fbb.CreateString(event_id) : 0,
      pass_probability,
      the_event_type,
      the_event);
}

struct OutcomeEventBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<OutcomeEventHolder>> *events() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OutcomeEventHolder>> *>(VT_EVENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENTS) &&
           verifier.Verify(events()) &&
           verifier.VerifyVectorOfTables(events()) &&
           verifier.EndTable();
  }
};

struct OutcomeEventBatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_events(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OutcomeEventHolder>>> events) {
    fbb_.AddOffset(OutcomeEventBatch::VT_EVENTS, events);
  }
  explicit OutcomeEventBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OutcomeEventBatchBuilder &operator=(const OutcomeEventBatchBuilder &);
  flatbuffers::Offset<OutcomeEventBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutcomeEventBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutcomeEventBatch> CreateOutcomeEventBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OutcomeEventHolder>>> events = 0) {
  OutcomeEventBatchBuilder builder_(_fbb);
  builder_.add_events(events);
  return builder_.Finish();
}

inline flatbuffers::Offset<OutcomeEventBatch> CreateOutcomeEventBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<OutcomeEventHolder>> *events = nullptr) {
  return reinforcement_learning::messages::flatbuff::CreateOutcomeEventBatch(
      _fbb,
      events ? _fbb.CreateVector<flatbuffers::Offset<OutcomeEventHolder>>(*events) : 0);
}

inline bool VerifyOutcomeEvent(flatbuffers::Verifier &verifier, const void *obj, OutcomeEvent type) {
  switch (type) {
    case OutcomeEvent_NONE: {
      return true;
    }
    case OutcomeEvent_StringEvent: {
      auto ptr = reinterpret_cast<const StringEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutcomeEvent_NumericEvent: {
      auto ptr = reinterpret_cast<const NumericEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutcomeEvent_ActionTakenEvent: {
      auto ptr = reinterpret_cast<const ActionTakenEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyOutcomeEventVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOutcomeEvent(
        verifier,  values->Get(i), types->GetEnum<OutcomeEvent>(i))) {
      return false;
    }
  }
  return true;
}

inline const reinforcement_learning::messages::flatbuff::OutcomeEventBatch *GetOutcomeEventBatch(const void *buf) {
  return flatbuffers::GetRoot<reinforcement_learning::messages::flatbuff::OutcomeEventBatch>(buf);
}

inline const reinforcement_learning::messages::flatbuff::OutcomeEventBatch *GetSizePrefixedOutcomeEventBatch(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<reinforcement_learning::messages::flatbuff::OutcomeEventBatch>(buf);
}

inline bool VerifyOutcomeEventBatchBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<reinforcement_learning::messages::flatbuff::OutcomeEventBatch>(nullptr);
}

inline bool VerifySizePrefixedOutcomeEventBatchBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<reinforcement_learning::messages::flatbuff::OutcomeEventBatch>(nullptr);
}

inline void FinishOutcomeEventBatchBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<reinforcement_learning::messages::flatbuff::OutcomeEventBatch> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOutcomeEventBatchBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<reinforcement_learning::messages::flatbuff::OutcomeEventBatch> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuff
}  // namespace messages
}  // namespace reinforcement_learning

#endif  // FLATBUFFERS_GENERATED_OUTCOMEEVENT_REINFORCEMENT_LEARNING_MESSAGES_FLATBUFF_H_
